import path from 'path';
import fs from 'fs';
import * as XLSX from 'xlsx';
import { TypeId, Type, parseTypeDefine } from './type';
import { parseValue } from './value';

type Headers = Record<string, { type: Type; isServer: boolean; isClient: boolean; }>;
type Values = Record<string, unknown>[];

function parseHeaders(types: Record<string, unknown>, servers: Record<string, unknown>, clients: Record<string, unknown>): Headers {
    const headers: Headers = {};
    for (let key in types) {
        const raw = types[key];
        if (raw == null || typeof raw !== 'string') {
            throw new Error(`Invalid type definition for ${key}: ${raw}`);
        }
        const define = raw.trim();
        if (define.length === 0) {
            throw new Error(`Empty type definition for ${key}`);
        }
        let type: Type;
        try {
            type = parseTypeDefine(define);
        } catch (e) {
            throw new Error(`Parse type failed for ${key}: ${define}, ${e}`);
        }
        const isServer = String(servers[key]).trim().toLowerCase() === 'server';
        const isClient = String(clients[key]).trim().toLowerCase() === 'client';
        headers[key] = {
            type: type,
            isServer: isServer,
            isClient: isClient,
        };
    }
    return headers;
}

function generateTypeName(interfaces: string[], interfaceName: string, key: string, type: Type): string {
    if (type.typeId === TypeId.Boolean) {
        return 'boolean';
    } else if (type.typeId === TypeId.Number) {
        return 'number';
    } else if (type.typeId === TypeId.Int) {
        return 'number';
    } else if (type.typeId === TypeId.String) {
        return 'string';
    } else if (type.typeId === TypeId.Object) {
        const name = `${interfaceName}${key.charAt(0).toUpperCase()}${key.slice(1)}`;
        generateInteface(interfaces, name, type.fields!);
        return name;
    } else {
        throw new Error(`Cannot generate type name for ${type}`);
    }
}

function generateInteface(interfaces: string[], name: string, fields: Record<string, Type>): void {
    const buffer: string[] = [`    export interface ${name} {`];
    for (let key in fields) {
        const fieldType = fields[key];
        if (fieldType.typeId === TypeId.Array) {
            let suffix = '[]';
            let elemType = fieldType.elemType!;
            while (elemType.typeId === TypeId.Array) {
                suffix += '[]';
                elemType = elemType.elemType!;
            }
            buffer.push(`        ${key}: ${generateTypeName(interfaces, name, key, elemType)}${suffix};`);
        } else {
            buffer.push(`        ${key}: ${generateTypeName(interfaces, name, key, fieldType)};`);
        }
    }
    buffer.push('    }');
    interfaces.push(buffer.join('\n'));
}

function generateTypeDefineContent(name: string, headers: Headers, isServer: boolean): string {
    const interfaces: string[] = [];
    const fields: Record<string, Type> = {};
    for (let key in headers) {
        const header = headers[key];
        if (isServer) {
            if (header.isServer) {
                fields[key] = header.type;
            }
        } else {
            if (header.isClient) {
                fields[key] = header.type;
            }
        }
    }
    generateInteface(interfaces, name, fields);
    return interfaces.join('\n');
}

function writeJsonAndTs(dir: string, name: string, headers: Headers, values: Values, isServer: boolean): void {
    const jsonPath = path.join(dir, `${name}.json`);
    const jsonData = JSON.stringify(values, null, 4);
    fs.writeFileSync(jsonPath, jsonData, 'utf8');

    const tsPath = path.join(dir, `${name}.ts`);
    const lines: string[] = [
        '// This file is auto generated by xlsx',
        `import data from './${name}.json';`,
        '',
        'export namespace xlsx {',
        generateTypeDefineContent(name, headers, isServer),
        '} // namespace xlsx',
        '',
        `export default data as xlsx.${name}[];`
    ];
    const tsData = lines.join('\n');
    fs.writeFileSync(tsPath, tsData, 'utf8');
}

function exportExcel(name: string, filePath: string, serverDir: string, clientDir: string) {
    const workbook = XLSX.readFile(filePath);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const lines = XLSX.utils.sheet_to_json(worksheet, { range: 1, defval: '' });

    if (lines.length < 3) {
        throw new Error('Invalid excel format');
    }

    const types = lines[0];
    const servers = lines[1];
    const clients = lines[2];

    if (types == null || typeof types !== 'object' || Array.isArray(types)) {
        throw new Error(`Invalid type definition header`);
    }
    if (servers == null || typeof servers !== 'object' || Array.isArray(servers)) {
        throw new Error(`Invalid server definition header`);
    }
    if (clients == null || typeof clients !== 'object' || Array.isArray(clients)) {
        throw new Error(`Invalid client definition header`);
    }

    const headers = parseHeaders(
        types as Record<string, unknown>,
        servers as Record<string, unknown>,
        clients as Record<string, unknown>
    );

    const serverList: Values = [];
    const clientList: Values = [];
    for (let i = 3; i < lines.length; i++) {
        const serverRecord: Record<string, unknown> = {};
        const clientRecord: Record<string, unknown> = {};
        const line = lines[i] as Record<string, unknown>;
        for (const key in headers) {
            const header = headers[key];
            const value = parseValue(line[key], header.type);
            if (header.isServer) {
                serverRecord[key] = value;
            }
            if (header.isClient) {
                clientRecord[key] = value;
            }
        }
        if (Object.keys(serverRecord).length !== 0) {
            serverList.push(serverRecord);
        }
        if (Object.keys(clientRecord).length !== 0) {
            clientList.push(clientRecord);
        }
    }

    if (serverList.length !== 0) {
        writeJsonAndTs(serverDir, name, headers, serverList, true);
    }
    if (clientList.length !== 0) {
        writeJsonAndTs(clientDir, name, headers, clientList, false);
    }
}

export { exportExcel };